// Copyright 2019-2022 Matt Layher
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package corerad

import (
	"context"
	"errors"
	"fmt"
	"math/rand"
	"net/netip"
	"sync"
	"time"

	"github.com/mdlayher/corerad/internal/config"
	"github.com/mdlayher/corerad/internal/netstate"
	"github.com/mdlayher/corerad/internal/system"
	"github.com/mdlayher/ndp"
	"github.com/mdlayher/schedgroup"
	"golang.org/x/sync/errgroup"
)

// An Advertiser sends NDP router advertisements.
type Advertiser struct {
	// OnInconsistentRA is an optional hook that fires when a router advertisement
	// is received that is inconsistent with the configuration being served by
	// this Advertiser, resulting in potential problems for clients. ours is
	// the RA generated by this Advertiser, and theirs is the RA received from
	// a remote router. If OnInconsistentRA is nil, the hook is not fired.
	OnInconsistentRA func(ours, theirs *ndp.RouterAdvertisement)

	// Static configuration.
	cctx *Context
	cfg  config.Interface

	// Socket creation and system state manipulation.
	dialer *system.Dialer
	watchC <-chan netstate.Change

	// Readiness notification.
	readyOnce sync.Once
	readyC    chan struct{}

	// terminate reports whether or not the Advertiser should fully terminate on
	// shutdown by sending a final router advertisement with a default lifetime
	// of zero, indicating to clients that they should not use this router for
	// their default route.
	terminate func() bool

	// Parameters which have defaults but may be explicitly overridden to speed
	// up tests.
	minDelayBetweenRAs time.Duration
}

// NewAdvertiser creates an Advertiser for the specified interface. If ll is
// nil, logs are discarded. If mm is nil, metrics are discarded.
func NewAdvertiser(
	cctx *Context,
	cfg config.Interface,
	dialer *system.Dialer,
	watchC <-chan netstate.Change,
	terminate func() bool,
) *Advertiser {
	return &Advertiser{
		cctx:      cctx,
		cfg:       cfg,
		dialer:    dialer,
		watchC:    watchC,
		readyC:    make(chan struct{}),
		terminate: terminate,

		// RFC defaults which can be overridden.
		minDelayBetweenRAs: minDelayBetweenRAs,
	}
}

// Run initializes the configured interface and begins router solicitation and
// advertisement handling. Run will block until ctx is canceled or an error
// occurs.
func (a *Advertiser) Run(ctx context.Context) error {
	return a.dialer.Dial(ctx, func(ctx context.Context, dctx *system.DialContext) error {
		// We can now initialize any plugins that rely on dynamic information
		// about the network interface.
		for _, p := range a.cfg.Plugins {
			if err := p.Prepare(dctx.Interface); err != nil {
				return fmt.Errorf("failed to prepare plugin %q: %v", p.Name(), err)
			}

			a.logf("%q: %s", p.Name(), p)
		}

		// Before starting any other goroutines, verify that the interface can
		// actually be used to send an initial router advertisement, avoiding a
		// needless start/error/restart loop.
		//
		// TODO: don't do this for unicast-only mode.
		if err := a.send(dctx.Conn, netip.IPv6LinkLocalAllNodes(), a.cfg); err != nil {
			return fmt.Errorf("failed to send initial multicast router advertisement: %v", err)
		}

		// Note unicast-only mode in logs.
		var method string
		if a.cfg.UnicastOnly {
			method = "unicast-only "
		}

		// Note readiness on first successful init.
		a.readyOnce.Do(func() { close(a.readyC) })
		a.logf("initialized, advertising %sfrom %s", method, dctx.IP)

		// Advertise until an error occurs, reinitializing under certain
		// circumstances.
		err := a.advertise(ctx, dctx.Conn)
		switch {
		case errors.Is(err, context.Canceled):
			// Intentional shutdown.
			a.shutdown(dctx.Conn)
			return nil
		case err == nil:
			panic("corerad: advertise must never return nil error")
		default:
			return err
		}
	})
}

// Ready implements Task.
func (a *Advertiser) Ready() <-chan struct{} { return a.readyC }

// String implements Task.
func (a *Advertiser) String() string { return fmt.Sprintf("advertiser %q", a.cfg.Name) }

// advertise is the internal loop for Advertise which coordinates the various
// Advertiser goroutines.
func (a *Advertiser) advertise(ctx context.Context, conn system.Conn) error {
	// Attach the context to the errgroup so that goroutines are canceled when
	// one of them returns an error.
	eg, ctx := errgroup.WithContext(ctx)

	ipC := make(chan netip.Addr, 16)

	// RA scheduler which consumes requests to send RAs and dispatches them
	// at the appropriate times.
	eg.Go(func() error {
		if err := a.schedule(ctx, conn, ipC); err != nil {
			return fmt.Errorf("failed to schedule router advertisements: %w", err)
		}

		return nil
	})

	// Multicast RA generator, unless running in unicast-only mode.
	if !a.cfg.UnicastOnly {
		eg.Go(func() error {
			a.multicast(ctx, ipC)
			return nil
		})
	}

	// Listener which issues RAs in response to RS messages.
	eg.Go(func() error {
		l := newListener(a.cctx, a.cfg.Name, conn)
		return l.Listen(ctx, func(msg message) error {
			ip, err := a.handle(msg.Message, msg.Host)
			if err != nil {
				return fmt.Errorf("failed to handle NDP message: %w", err)
			}
			if ip != nil {
				ipC <- *ip
			}

			return nil
		})
	})

	eg.Go(linkStateWatcher(ctx, a.watchC))

	if err := eg.Wait(); err != nil {
		return fmt.Errorf("failed to run advertiser: %w", err)
	}

	// Should only reach this state when context is canceled on shutdown.
	return ctx.Err()
}

// Constants taken from https://tools.ietf.org/html/rfc4861#section-10.
const (
	maxInitialAdvInterval = 16 * time.Second
	maxInitialAdv         = 3
	minDelayBetweenRAs    = 3 * time.Second
	maxRADelay            = 500 * time.Millisecond
)

// multicast runs a multicast advertising loop until ctx is canceled.
func (a *Advertiser) multicast(ctx context.Context, ipC chan<- netip.Addr) {
	// Initialize PRNG so we can add jitter to our unsolicited multicast RA
	// delay times.
	var (
		prng = rand.New(rand.NewSource(time.Now().UnixNano()))
		min  = a.cfg.MinInterval
		max  = a.cfg.MaxInterval
	)

	for i := 0; ; i++ {
		// Enable cancelation before sending any messages, if necessary.
		select {
		case <-ctx.Done():
			return
		default:
		}

		ipC <- netip.IPv6LinkLocalAllNodes()

		select {
		case <-ctx.Done():
			return
		case <-time.After(multicastDelay(prng, i, min, max)):
		}
	}
}

// handle handles an incoming NDP message from a remote host.
func (a *Advertiser) handle(m ndp.Message, host netip.Addr) (*netip.Addr, error) {
	a.cctx.mm.AdvMessagesReceivedTotal(1.0, a.cfg.Name, m.Type().String())

	switch m := m.(type) {
	case *ndp.RouterSolicitation:
		a.debugf("received router solicitation from IP %q, source link-layer address %q",
			host, sourceLLA(m.Options))

		// Issue a unicast RA for clients with valid addresses, or a multicast
		// RA for any client contacting us via the IPv6 unspecified address,
		// per https://tools.ietf.org/html/rfc4861#section-6.2.6.
		if host.IsUnspecified() {
			host = netip.IPv6LinkLocalAllNodes()
		}

		// TODO: consider checking for numerous RS in succession and issuing
		// a multicast RA in response.
		return &host, nil
	case *ndp.RouterAdvertisement:
		a.debugf("received router advertisement from IP %q, source link-layer address %q, router lifetime %s",
			host, sourceLLA(m.Options), m.RouterLifetime)

		// Received a router advertisement from a different router on this
		// LAN, verify its consistency with our own.
		want, err := a.buildRA(a.cfg)
		if err != nil {
			return nil, fmt.Errorf("failed to build router advertisement: %w", err)
		}

		// Ensure the RAs are consistent.
		problems := verifyRAs(want, m)
		if len(problems) == 0 {
			break
		}

		// RAs are not consistent, report this per the RFC.
		//
		// Report and increment metrics before the caller hook is invoked,
		// to ensure that the output is visible to callers if they request
		// it, such as in the tests.
		a.logf("inconsistencies detected in router advertisement from router with IP %q, source link-layer address %q",
			host, sourceLLA(m.Options))

		for i, p := range problems {
			var details string
			if p.Details != "" {
				details = fmt.Sprintf("(%s) ", p.Details)
			}

			a.logf("inconsistency %d: %q: %s%s", i, p.Field, details, p.Message)
			a.cctx.mm.AdvRouterAdvertisementInconsistenciesTotal(1.0, a.cfg.Name, p.Details, p.Field)
		}

		if a.OnInconsistentRA != nil {
			a.OnInconsistentRA(want, m)
		}
	default:
		a.logf("advertiser received NDP message of type %T from %s, ignoring", m, host)
		a.cctx.mm.MessagesReceivedInvalidTotal(1.0, a.cfg.Name, m.Type().String())
	}

	// No response necessary.
	return nil, nil
}

// schedule consumes RA requests and schedules them with workers so they may
// occur at the appropriate times.
func (a *Advertiser) schedule(ctx context.Context, conn system.Conn, ipC <-chan netip.Addr) error {
	// Enable canceling schedule's context on send RA error.
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	var (
		// Schedule router advertisements and handles any errors from those
		// advertisements. Note that sg.Wait cannot be used for that purpose
		// because it is invalid to call Wait and schedule other work after,
		// meaning that we can only Wait once we're exiting this function.
		sg   = schedgroup.New(ctx)
		errC = make(chan error)

		// Jitter for RA delays.
		prng = rand.New(rand.NewSource(time.Now().UnixNano()))

		// Assume that a.init sent the initial RA recently and space out others
		// accordingly.
		lastMulticast = time.Now()
	)

	for {
		// New IP for each loop iteration to prevent races.
		var ip netip.Addr

		select {
		case err := <-errC:
			// We received an error and will need to determine if we can
			// reinitialize the listener. Don't schedule any more tasks and
			// return the error immediately.
			cancel()
			_ = sg.Wait()
			return err
		case <-ctx.Done():
			// Context cancelation is expected.
			if err := sg.Wait(); err != nil && err != context.Canceled {
				return err
			}

			return nil
		case ip = <-ipC:
		}

		if !ip.IsMulticast() {
			// This is a unicast RA. Delay it for a short period of time per
			// the RFC and then send it.
			delay := time.Duration(prng.Int63n(maxRADelay.Nanoseconds())) * time.Nanosecond
			sg.Delay(delay, func() {
				if err := a.sendWorker(conn, ip); err != nil {
					errC <- err
				}
			})
			continue
		}

		// Ensure that we space out multicast RAs as required by the RFC.
		var delay time.Duration
		if time.Since(lastMulticast) < a.minDelayBetweenRAs {
			delay = a.minDelayBetweenRAs
		}

		// Ready to send this multicast RA.
		lastMulticast = time.Now()
		sg.Delay(delay, func() {
			if err := a.sendWorker(conn, ip); err != nil {
				errC <- err
			}
		})
	}
}

// sendWorker is a goroutine worker which sends a router advertisement to ip.
func (a *Advertiser) sendWorker(conn system.Conn, ip netip.Addr) error {
	if err := a.send(conn, ip, a.cfg); err != nil {
		a.logf("failed to send scheduled router advertisement to %s: %v", ip, err)
		a.cctx.mm.AdvErrorsTotal(1.0, a.cfg.Name, "transmit")
		return err
	}

	typ := "unicast"
	if ip.IsMulticast() {
		typ = "multicast"
		a.cctx.mm.AdvLastMulticastTime(float64(time.Now().Unix()), a.cfg.Name)
	}

	a.cctx.mm.AdvRouterAdvertisementsTotal(1.0, a.cfg.Name, typ)
	return nil
}

// send sends a single router advertisement built from cfg to the destination IP
// address, which may be a unicast or multicast address.
func (a *Advertiser) send(conn system.Conn, dst netip.Addr, cfg config.Interface) error {
	if cfg.UnicastOnly && dst.IsMulticast() {
		// Nothing to do.
		return nil
	}

	// Build a router advertisement from configuration and always append
	// the source address option.
	ra, err := a.buildRA(cfg)
	if err != nil {
		return fmt.Errorf("failed to build router advertisement: %w", err)
	}

	if err := conn.WriteTo(ra, nil, dst); err != nil {
		return fmt.Errorf("failed to send router advertisement to %s: %w", dst, err)
	}

	return nil
}

// buildRA builds a router advertisement from configuration.
func (a *Advertiser) buildRA(ifi config.Interface) (*ndp.RouterAdvertisement, error) {
	// Check for any system state changes which could impact the router
	// advertisement, and then build it using an interface configuration.
	forwarding, err := a.cctx.state.IPv6Forwarding(ifi.Name)
	if err != nil {
		return nil, fmt.Errorf("failed to get IPv6 forwarding state: %w", err)
	}

	ra, ms, err := ifi.RouterAdvertisement(forwarding)
	if err != nil {
		return nil, fmt.Errorf("failed to generate router advertisement: %v", err)
	}

	// Report any RA misconfigurations which may result in unexpected behavior,
	// so the user can more readily remedy any issues.
	for _, m := range ms {
		switch m {
		case config.InterfaceNotForwarding:
			a.logf("interface is not configured for IPv6 forwarding, refusing to advertise a default route (default lifetime: %s)",
				ifi.DefaultLifetime)
		default:
			panicf("corerad: unhandled config.Misconfiguration: %d", m)
		}
	}

	return ra, nil
}

// shutdown indicates to hosts that this host is no longer a router.
func (a *Advertiser) shutdown(conn system.Conn) {
	if !a.terminate() {
		// A supervisor daemon has indicated that the process will be restarted
		// after shutdown, so we should not force all clients to drop their
		// default route to this router.
		return
	}

	// It's expected that the process will terminate and not be restarted. Send
	// a final router advertisement with a router lifetime of 0 to indicate that
	// hosts should not use this router as a default router.
	//
	// a.cfg is copied in case any delayed send workers are outstanding and the
	// server's context is canceled.
	cfg := a.cfg
	cfg.DefaultLifetime = 0

	if err := a.send(conn, netip.IPv6LinkLocalAllNodes(), cfg); err != nil {
		a.logf("failed to send final multicast router advertisement: %v", err)
	}
}

// logf prints a formatted log with the Advertiser's interface name.
func (a *Advertiser) logf(format string, v ...interface{}) {
	a.cctx.ll.Printf(a.cfg.Name+": "+format, v...)
}

// debugf prints a formatted debug log if verbose mode is configured.
func (a *Advertiser) debugf(format string, v ...interface{}) {
	if !a.cfg.Verbose {
		return
	}

	a.logf("debug: %s", fmt.Sprintf(format, v...))
}

// multicastDelay selects an appropriate delay duration for unsolicited
// multicast RA sending.
func multicastDelay(r *rand.Rand, i int, min, max time.Duration) time.Duration {
	// Implements the algorithm described in:
	// https://tools.ietf.org/html/rfc4861#section-6.2.4.

	var d time.Duration
	if min == max {
		// Identical min/max, use a static interval.
		d = (max * time.Nanosecond).Round(time.Second)
	} else {
		// min <= wait <= max, rounded to 1 second granularity.
		d = (min + time.Duration(
			r.Int63n(max.Nanoseconds()-min.Nanoseconds()),
		)*time.Nanosecond).Round(time.Second)
	}

	// For first few advertisements, select a shorter wait time so routers
	// can be discovered quickly, per the RFC.
	if i < maxInitialAdv && d > maxInitialAdvInterval {
		d = maxInitialAdvInterval
	}

	return d
}

func panicf(format string, a ...interface{}) {
	panic(fmt.Sprintf(format, a...))
}
